2.2.1
n^3/1000 - 100n^2 - 100n + 3 = Theta(n^3)

2.2.2

#include <iostream>

void select_sort(int * arr, int size) {
	for (int j = 0; j < size - 1; ++j) {
		int min = arr[j];
		int pointer = j;
		for (int i = j + 1; i < size; ++i)
			if (arr[i] < min) {
				pointer = i;
				min = arr[i];
			}
		arr[pointer] = arr[j];
		arr[j] = min;
	}
}

int main() {
	int m[10] = {};
	for (int i = 0; i != 10; ++i) {
		std::cin >> m[i];
	}

	select_sort(m, 10);

	for (int i = 0; i != 10; ++i) {
		std:: cout << m[i] << ' ';
	}

	return 0;
}

T(n) = Theta(n^2)
Сортировка выбором не зависит от поданных данных, она в любом случае ищет минимум в оставшейся части массива, соответственно у нее нет худшего или лучшего варината (внутренность if) не будет выполняться ни разу, если массив отсортирован. Но зато он делает лишь Theta(n) перестановок.
Инвариант: [0, j] -- отсортирован.

Нужно проверять n-1 элементов, потому что последний автоматически остается самым большим (большим чем, остальные элементы, то есть он автоматически будет находиться на своем месте)

2.2.3
В среднем, если известно, что вероятность элемента массива иметь исходное значение равно p, то надо в среднем и сделать n/p проверок. Алгоритм линейного поиска работает в лучшем случае за Theta(1) (первый элемент уже искомый, то есть больше ничего не надо проверять, одно сравнение), а в худшем за Theta(n) (элемента нет, надо сделать n сравнений).

2.2.4
Для получения оптимальной работы в лучшем случае нужно добавить проверку типа is_sorted, и тогда лучший случай всегда будет обрабатываться за Theta(n).