6.5.1
Покажем работу extract-max
A = [15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1]
max = 15 A = [1, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2]
A = [13, 1, 9, 5, 12, 8, 7, 4, 0, 6, 2]
A = [13, 12, 9, 5, 1, 8, 7, 4, 0, 6, 2]
A = [13, 12, 9, 5, 6, 8, 7, 4, 0, 1, 2]

6.5.2
Покажем работу insert
A = [15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1, -inf]
A = [15, 13, 9, 5, 12, 8, 7, 4, 0, 6, 2, 1, 10]
A = [15, 13, 9, 5, 12, 10, 7, 4, 0, 6, 2, 1, 8]
A = [15, 13, 10, 5, 12, 9, 7, 4, 0, 6, 2, 1, 8]

6.5.3
Все процедуры абсолютно идентичны таквым для невозрастающей пирамиды.

6.5.4
Для того, чтобы процедура не выдала ошибки. Можно присвоить последнему элементу значение <=key, и алгоритм будет работать корректно.

6.5.5
В начале все, что меняется это величина i, поэтому все, что может быть неправильно, это если величина parent(i) больше, ивариант сохраняется, далее мы меняем i и parent(i), если есть ошибка, он будет так же больше второго дочернего узла, так как предыдущие узел в иезначальной пирамиде был больше. В окночании цикла, i становится корнем и все условия пирамиды выполняются.

6.5.6
Нужно заменить ы 4 строке A[i] на key, и в 5 строке делать присваивание A[i] = A[parent(i)], а потом уже сделать присваивание A[i] = key.

6.5.7
Нужно просто заести отдельное поле в структуре, которое будет отвечать за количество добавленных элементов, при добавлении нового, значение счетчика использовать вместо значения ключа.

6.5.8
Heap-increase-key(A, i, infty)
A[1] = A[A.heap-size]
A.heap-size -= 1
max-hepify(A, 1)