6.3.1
Посмторим, как работает build-max-heap:
A = [5, (3, 17), ((10, 84)), ((19, 6)), (((22, 9)))]
A = [5, (3, 17), ((22, 84)), ((19, 6)), (((10, 9)))]
A = [5, (3, 19), ((22, 84)), ((17, 6)), (((10, 9)))]
A = [5, (84, 19), ((22, 3)), ((17, 6)), (((10, 9)))]
A = [84, (5, 19), ((22, 3)), ((17, 6)), (((10, 9)))]
A = [84, (22, 19), ((5, 3)), ((17, 6)), (((10, 9)))]
A = [84, (22, 19), ((10, 3)), ((17, 6)), (((5, 9)))]

6.3.2
Если бы она начиналась с 1, то не было бы гарантий, что получится в результате правильная куча, как например, в массиве [2, 1, 1, 3], 2 осталась бы на месте.

6.3.3
Все узлы высотой h разделяют набор листьев на наборы размера 2^(h - 1) + 1 и 2^h, где все, кроме одного рамера 2^h. Просто поставив каждый дочерний узел в свою часть разбения дерева получим, учитывая, что максимум в дереве 2^(floor(lg(n)) листьев, и то что каждый дочерний узел высоты h разделяется на две части минимум размера 2^(h - 1) + 1, и что все, кроме одного соответсвуют части размера 2^h, то если k -- это колическво, которое мы хотим найти, то:
(k - 1)*2^h + k(2^(h - 1) + 1) <= 2^(floor(lg n)) <= n / 2
откуда следует, что:
k <= ceil(n/2^(h + 1))