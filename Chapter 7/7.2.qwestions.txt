7.2.1
T(n) = T(n - 1) + Theta(n)
T(n) <= dn^2
T(n) <= d(n - 1)^2 + cn = dn^2 - 2dn + d + cn <= dn^2, d >= cn/(2n - 1) >= c, n  -- любое.

7.2.2
Время работы quick_sort в случае когда все элементы одинаковы равно T(n^2), потому что разбиение всегда будет по последнему элементу, то есть реализкется наихудший случай.

7.2.3
Время работы quick_sort в случае, когда все элементы расположены в убывающем порядке также будет наихудшим, так как опорный элемент всегда будет меньше всех остальных и будет выполняться рекррентное соотношение T(n) = T(n - 1) + Theta(n)

7.2.4
Пусть под почти отсортированным массивом имеется ввиду то, что каждый элемент i не более чем на c отстает от своего настоящего места, для некоторой константы c, тогда при сортировке вставкой будет произведено не более cn операций, то есть время работы бкдет O(cn) = O(n), так как c это некая заранее фиксированная константа. Для быстрой же сортировки лучшее разбиение процедуры partion будет c - n и c, что приводит к O(n^2) работе по времени.

7.2.5
Самая короткая ветвь будет в том случае, где идет самая малая часть разбиения, то есть 1 = (a)^k_min*n, k_min = -log(n)/log(a). Самая длинная ветвь рекурсии будет там, где берется каждый раз самая большая часть, то есть 1 = (1 - a)^(k_max)*n, k_max = -log(n)/log(1 - a)

7.2.6
Без ограничения общности предположим, что изначальный массив перемешан равновероятно, и пусть k -- это количество элементов, котороые меньше последнего элемента. an <= k <= (1 - a)n, это случается с вероятностью ((1 - a)n - an + 1)/n = 1 - 2a + 1/n ~ 1 - 2a.